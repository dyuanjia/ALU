module fsm_tester (
    input clk,  // clock
    input rst,  // reset
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],    // DIP switches on IO Shield
    input a [16],
    input b [16],
    output out [16]
  ) {
  
  const DIV = 26;           // regulates the speed in which the inputs are generated
  
  .clk(clk) {
    .rst(rst) {
      fsm test_modules = {ADD, BOOL, SHIFT, CMP, MUL, DIVIDE}; // instance of a finite state machine
      dff ctr[3+DIV];                     // use a flip flop as a counter for different inputs
      dff buffer[DIV];                    // buffer between change in input and error checking
      display seg;                        // instance used to display error message
    }
  }
  
  // alu alu16;
  
  always {
    io_led = 3x{{8h00}};     // turn LEDs off
    io_seg = ~seg.seg;       // connect segments to the driver
    io_sel = ~seg.sel;       // connect select to the driver
    // increment buffer counter
    
    // initialize variables
    seg.chars = {4h0, 4h0, 4h0, 4h0};
    out = 16b0;
    
    case (test_modules.q) {
      test_modules.ADD:     // testing adder module
        // TODO
          
        if (io_button[1])
          test_modules.d = test_modules.BOOL; // transition to next module
        
      test_modules.BOOL:     // testing boolean module
        // TODO
        
        // counter example
        io_led[1][2-:3] = ctr.q[3+DIV-1-:3]; // set the LED output
        ctr.d = ctr.q + 1;                   // increment
        buffer.d = c{0, (DIV-1)x{1}};
        buffer.d = buffer.q + 1;
        
        //a = ctr.q[1+DIV];                    // second most significant bit represents input a
        //b = ctr.q[DIV];                      // third most significant bit represents input b
        //cin = ctr.q[2+DIV];                  // most significant bit represents input carry-in
        
        
        if (ctr.q == 0) {                      // overflow?
          test_modules.d = test_modules.SHIFT;
        }
      
      test_modules.SHIFT:     // testing shifter module
        // TODO
        
        // message display example
        seg.chars = {4h1, 4h2, 4h3, 4h4};
      
      test_modules.CMP:     // testing shifter module
        // TODO
        out = 16b0;
        
      test_modules.MUL:     // testing multiply module
        // TODO
        out = 16b0;
        
      test_modules.DIVIDE:     // testing divide module
        // TODO
        out = 16b0;
    }
  }
}
